# Django on Convox Example

This repository contains an example Django 1.9.7 app configured for local development and deployment to Convox.

The following is a step-by-step walkthrough of how the app was configured and why.

## The Django Project and App

The [first commit](https://github.com/convox-examples/django/commit/db374e06e63d437353394dad8e3d9be015df10c1) contains the files generated by running `django-admin startproject exampleproject` via the Django 1.9.7 package.

The [second commit](https://github.com/convox-examples/django/commit/c7f306a21629f04aa33da402379397fae382ab4c) contains the files generated by running `python manage.py startapp exampleapp` from within the same directory as `manage.py`.

## Convox Init

The Convox CLI contains a command called `convox init`, which we used to generate the files in the [third commit](https://github.com/convox-examples/django/commit/4d22973fc66d37c8a87a19f2b4263adbd5131e4d): `Dockerfile`, `docker-compose.yml`, and `.dockerignore`.

Since Convox uses Docker for containerization, these files are necessary to describe the application's containers and how to build them. The generated files are good defaults for most Django apps, and they can also be edited to suit your specific needs.

### Dockerfile

#### convox/django Docker image

The generated Dockerfile inherits from the [convox/django Docker image](https://hub.docker.com/r/convox/django/), which has all the packages and configuration necessary to run your Django app both locally and in production. This includes:

* OS libraries to support PostgreSQL, MySQL, and sqlite3 databases
* nginx for proxying client connections
* a Convox-friendly nginx config file
* a bin/web script for booting the app

#### how Dockerfile describes the build

Starting from the `convox/django` image, the [generated Dockerfile](https://github.com/convox-examples/django/blob/master/Dockerfile) executes the remaining build steps that your Django project needs. There are basically 3 steps in this process, and they are executed in a particular order to take advantage of Docker's build caching behavior.

1. `requirements.txt` is copied and `pip3 install` is run. This happens first because it is slow and something that's done infrequently. After running once, this step will be cached unless the cache is busted by later edits to `requirements.txt`.

2. All the static files from the django project are copied, and those are then collected in `STATIC_ROOT` using `collectstatic`. In this example project, we've assumed a basic directory structure with static app files in `exampleapp/static/` and `STATIC_ROOT` set to `static/`. Again, this is done early in the build process to optimize caching. The asset building step will only be run in the future if these files have changed.

3. The rest of the application source is copied over. These files will change frequently, so this step of the build will very rarely be cached.

### docker-compose.yml

The [docker-compose.yml](https://github.com/convox-examples/django/blob/master/docker-compose.yml) file explains how to run the containers that make up your app. This generated file describes a `web` service from which your main Django web containers will be created. The various sections of the `web` service configuration are described below:

#### build

```yaml
build: .
```

This entry declares that the `web` container(s) should use an image built from the Dockerfile in the root (`.`) of your project directory.

#### labels

```yaml
labels:
  - convox.port.443.protocol=tls
  - convox.port.443.proxy=true
```

The labels section is used by Convox for configuration not covered by the official Compose spec.  Here we're using it to configure how the load balancer handles traffic on port 443.

`convox.port.443.protocol=tls` means that the load balancer listens on port 443 in TLS mode, accepting encrypted traffic and using your application's certificate to decrypt the messages.

`convox.port.443.proxy=true` means that PROXY protocol TCP headers are injected into requests on port 443. These headers can then be used by nginx to set the HTTP headers your Django application expects.

See the [load balancer documentation](https://convox.com/docs/load-balancers/) for more detailed info.

#### ports

```yaml
ports:
  - 80:4000
  - 443:4001
```

The ports section lets you declare a mapping of ports of the host to those inside the container. In this case, the container listens on ports 80 and 443 for http and https traffic. These requests get routed to ports 4000 and 4001 inside the container. In this example, nginx is configured (see the relevant [nginx.conf](https://github.com/convox/django/blob/master/conf/nginx.conf)) to listen on ports 4000 and 4001.

### .dockerignore

`convox init` also generates a [.dockerignore](https://github.com/convox-examples/django/blob/master/.dockerignore) file that ignores files and directories not needed in the app's Docker image. It's important to have a good `.dockerignore` to keep images small and builds, pushes and pulls fast.

## Linking a database container

Up to this point the app has been using sqlite3 for its database. In a production environment, however, a database like PostgreSQL is more likely to be used. Linking a Postgres container to your app is pretty straightforward. Here's how we did it in this example.

### Update the app

Django lets you specify database settings via its `DATABASES` dictionary, which is found in `settings.py`. By default, the dictionary contains settings for SQLite. To use PostgreSQL, we'll need to specify a different set of connection parameters.

We could set these parameters directly in `settings.py`, but with Convox, the preferred approach is to push this configuration out of the codebase and into a `DATABASE_URL` environment variable. See [The 12-Factor App](http://12factor.net/config) for more on this topic.

We'll get to how Convox sets `DATABASE_URL` [later](#link-database-to-web). For now, we'll assume Convox provides the database connection parameters we need in URL format, which makes our task parsing that URL and converting it to the format expected by Django's `DATABASES` dictionary. That's where the dj_database_url utility comes in handy.

By [replacing](https://github.com/convox-examples/django/commit/7537b7744cf5f3ae639a405fe97799cdfa17f9c0) the default SQLite database settings with a call to `dj_database_url.config`, we tell Django that it can connect to its new 'default' PostgreSQL database by using parameters derived from the `DATABASE_URL` set by Convox.

### Add a database service

We want to run a Postgres container for local development, so the next step is to [add](https://github.com/convox-examples/django/commit/7537b7744cf5f3ae639a405fe97799cdfa17f9c0) it to `docker-compose.yml`.

We define a service called `database`, and use the `convox/postgres` image:

```yaml
database:
  image: convox/postgres
  ports:
    - 5432
```

We want the database to listen for connections on port 5432. When we deploy this app an internal TCP load balancer will be created to listen on that port.

### Link database to web

Lastly, we need to link the database container to the web container. We do this by adding a `links` section to the `web` service definition:

```yaml
links:
  - database
```

This will cause a `DATABASE_URL` environment variable to be injected into the `web` environment, which it will use to connect to the database. You can read more about container linking [here](https://convox.com/docs/linking/).

A linked container works well for local development. However, when you deploy this app, you'll want a "real" Postgres. To accomplish this you can provision a hosted Postgres instance via [convox services](https://convox.com/docs/postgresql/), [scale](https://convox.com/docs/scaling/) your `database` container count in your app to 0, and set the DATABASE_URL [environment variable](https://convox.com/docs/environment/) to point to the hosted Postgres.

## Running the app Locally

In keeping with security best practices, we've [moved](https://github.com/convox-examples/django/commit/61bbe0eeac20cb97fa6f67ed75ebbe5829fef549) the hard-coded value of `SECRET_KEY` out of `settings.py`. That means you'll need to tell Convox to set it in the [environment](https://convox.com/docs/environment/) before you can run the app. Here's how:

1. Create a `.env` file in the uppermost directory of the project (same level as `README.md`)
1. Inside `.env`, set `SECRET_KEY=replace-with-any-value`

Now you're ready to run the application locally with Convox.

```bash
convox start
```

## Deploying the application

After [installing a Rack](https://convox.com/docs/installing-a-rack/):

```bash
convox apps create
convox env set SECRET_KEY=replace-with-sensitive-value
convox deploy
```
